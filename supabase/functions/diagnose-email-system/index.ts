import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { createClient } from "npm:@supabase/supabase-js@2";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Client-Info, Apikey",
};

interface DiagnosticResult {
  category: string;
  status: "success" | "warning" | "error";
  message: string;
  details?: any;
}

function createSafeResponse(data: any, status: number = 200) {
  try {
    const jsonString = JSON.stringify(data, null, 2);
    console.log(`‚úÖ Response prepared: ${jsonString.length} bytes, status ${status}`);
    return new Response(jsonString, {
      status,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json",
      },
    });
  } catch (error) {
    console.error("‚ùå Failed to stringify response:", error);
    return new Response(
      JSON.stringify({
        error: "Response serialization failed",
        message: error.message,
      }),
      {
        status: 500,
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      }
    );
  }
}

Deno.serve(async (req: Request) => {
  const requestId = crypto.randomUUID();
  console.log(`üîç [${requestId}] Diagnostic request received at ${new Date().toISOString()}`);

  if (req.method === "OPTIONS") {
    console.log(`‚úÖ [${requestId}] OPTIONS preflight handled`);
    return new Response(null, { status: 200, headers: corsHeaders });
  }

  try {
    console.log(`üìä [${requestId}] Starting diagnostic checks...`);
    const diagnostics: DiagnosticResult[] = [];
    let checkCount = 0;

    // 1. V√©rifier les variables d'environnement Resend
    console.log(`üìã [${requestId}] Check ${++checkCount}: Environment variables`);
    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    const resendDomain = Deno.env.get("RESEND_DOMAIN");
    const appDomain = Deno.env.get("APP_DOMAIN");

    diagnostics.push({
      category: "Configuration Resend",
      status: resendApiKey ? "success" : "error",
      message: resendApiKey
        ? "‚úÖ RESEND_API_KEY est configur√©e"
        : "‚ùå RESEND_API_KEY est MANQUANTE",
      details: {
        apiKeyExists: !!resendApiKey,
        apiKeyFormat: resendApiKey
          ? resendApiKey.startsWith("re_")
            ? "Correct (commence par re_)"
            : "‚ö†Ô∏è Format incorrect (devrait commencer par re_)"
          : "N/A",
        domain: resendDomain || "non configur√©",
        appDomain: appDomain || "non configur√©",
      },
    });
    console.log(`‚úÖ [${requestId}] Check ${checkCount} completed`);

    // 2. V√©rifier la validit√© de l'API Key Resend (sans envoyer d'email)
    if (resendApiKey) {
      console.log(`üìã [${requestId}] Check ${++checkCount}: Resend API Key validation`);
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);

        const domainsResponse = await fetch("https://api.resend.com/domains", {
          method: "GET",
          headers: {
            Authorization: `Bearer ${resendApiKey}`,
          },
          signal: controller.signal,
        });
        clearTimeout(timeoutId);

        const responseText = await domainsResponse.text();
        let domainsResult;
        try {
          domainsResult = JSON.parse(responseText);
        } catch (parseError) {
          console.error(`‚ùå [${requestId}] Failed to parse Resend response:`, responseText.substring(0, 200));
          throw new Error("Invalid JSON response from Resend API");
        }

        if (domainsResponse.ok) {
          const verifiedDomains = domainsResult.data?.filter((d: any) => d.status === "verified") || [];
          const configuredDomain = resendDomain || "non configur√©";
          const isDomainVerified = verifiedDomains.some((d: any) => d.name === configuredDomain);

          diagnostics.push({
            category: "API Key Resend",
            status: "success",
            message: "‚úÖ API Key Resend valide",
            details: {
              totalDomains: domainsResult.data?.length || 0,
              verifiedDomains: verifiedDomains.length,
              verifiedDomainsList: verifiedDomains.map((d: any) => d.name),
              configuredDomain,
              isDomainVerified,
            },
          });

          if (!isDomainVerified && configuredDomain !== "non configur√©") {
            diagnostics.push({
              category: "Configuration Domaine",
              status: "error",
              message: `‚ùå Le domaine configur√© "${configuredDomain}" n'est PAS v√©rifi√© dans Resend`,
              details: {
                configuredDomain,
                verifiedDomains: verifiedDomains.map((d: any) => d.name),
                hint: "Les emails seront envoy√©s √† delivered@resend.dev jusqu'√† ce que le domaine soit v√©rifi√©",
              },
            });
          } else if (isDomainVerified) {
            diagnostics.push({
              category: "Configuration Domaine",
              status: "success",
              message: `‚úÖ Le domaine "${configuredDomain}" est v√©rifi√© et pr√™t`,
              details: {
                configuredDomain,
                status: "verified",
              },
            });
          }
        } else {
          console.warn(`‚ö†Ô∏è [${requestId}] Resend API returned ${domainsResponse.status}`);
          diagnostics.push({
            category: "API Key Resend",
            status: "error",
            message: `‚ùå API Key invalide: ${domainsResult.message || "V√©rifiez votre cl√©"}`,
            details: {
              statusCode: domainsResponse.status,
              response: domainsResult,
            },
          });
        }
        console.log(`‚úÖ [${requestId}] Check ${checkCount} completed`);
      } catch (error) {
        console.error(`‚ùå [${requestId}] Resend API check failed:`, error);
        diagnostics.push({
          category: "API Key Resend",
          status: "error",
          message: `‚ùå Impossible de v√©rifier l'API Key: ${error.message}`,
          details: {
            error: error.message,
            name: error.name,
          },
        });
      }
    }

    // 3. V√©rifier la configuration Supabase
    console.log(`üìã [${requestId}] Check ${++checkCount}: Supabase configuration`);
    const supabaseUrl = Deno.env.get("SUPABASE_URL");
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    diagnostics.push({
      category: "Configuration Supabase",
      status: supabaseUrl && supabaseKey ? "success" : "error",
      message:
        supabaseUrl && supabaseKey
          ? "‚úÖ Variables Supabase configur√©es"
          : "‚ùå Variables Supabase manquantes",
      details: {
        supabaseUrlExists: !!supabaseUrl,
        serviceRoleKeyExists: !!supabaseKey,
      },
    });
    console.log(`‚úÖ [${requestId}] Check ${checkCount} completed`);

    // 4. V√©rifier les tables de la base de donn√©es
    if (supabaseUrl && supabaseKey) {
      console.log(`üìã [${requestId}] Check ${++checkCount}: Database tables`);
      const supabase = createClient(supabaseUrl, supabaseKey);

      const tables = [
        "waitlist",
        "appointment_slot_offers",
        "slot_offer_invitations",
        "waitlist_notifications",
        "waitlist_settings",
      ];

      for (const table of tables) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);

          const { count, error } = await supabase
            .from(table)
            .select("*", { count: "exact", head: true })
            .abortSignal(controller.signal);

          clearTimeout(timeoutId);

          diagnostics.push({
            category: `Table: ${table}`,
            status: error ? "error" : "success",
            message: error
              ? `‚ùå Erreur d'acc√®s √† ${table}`
              : `‚úÖ Table ${table} accessible (${count ?? 0} entr√©es)`,
            details: { count: count ?? 0, error: error?.message },
          });
        } catch (error) {
          console.error(`‚ùå [${requestId}] Table ${table} check failed:`, error.message);
          diagnostics.push({
            category: `Table: ${table}`,
            status: "error",
            message: `‚ùå Exception lors de l'acc√®s √† ${table}`,
            details: { error: error.message, name: error.name },
          });
        }
      }
      console.log(`‚úÖ [${requestId}] Check ${checkCount} completed`);

      // 5. V√©rifier les logs du trigger
      console.log(`üìã [${requestId}] Check ${++checkCount}: Trigger logs`);
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        const { data: triggerLogs, error: logError } = await supabase
          .from("waitlist_trigger_logs")
          .select("*")
          .order("created_at", { ascending: false })
          .limit(1)
          .abortSignal(controller.signal);

        clearTimeout(timeoutId);

        diagnostics.push({
          category: "Trigger Database",
          status: logError ? "warning" : "success",
          message: logError
            ? "‚ö†Ô∏è Impossible de v√©rifier les logs du trigger"
            : triggerLogs && triggerLogs.length > 0
            ? `‚úÖ Trigger actif - Dernier log: ${triggerLogs[0].status}`
            : "‚ÑπÔ∏è Trigger configur√© (aucune activit√© r√©cente)",
          details: {
            latest_log: triggerLogs?.[0] || null,
            error: logError?.message || null,
          },
        });
        console.log(`‚úÖ [${requestId}] Check ${checkCount} completed`);
      } catch (error) {
        console.error(`‚ö†Ô∏è [${requestId}] Trigger logs check failed:`, error.message);
        diagnostics.push({
          category: "Trigger Database",
          status: "warning",
          message: "‚ö†Ô∏è Impossible de v√©rifier les logs du trigger",
          details: { error: error.message, name: error.name },
        });
      }

      // 6. V√©rifier les invitations r√©centes
      console.log(`üìã [${requestId}] Check ${++checkCount}: Recent invitations`);
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        const { data: recentInvitations, error: invError } = await supabase
          .from("slot_offer_invitations")
          .select("*")
          .order("sent_at", { ascending: false })
          .limit(5)
          .abortSignal(controller.signal);

        clearTimeout(timeoutId);

        const safeInvitations = recentInvitations?.map((inv) => ({
          id: inv.id,
          status: inv.status,
          sent_at: inv.sent_at,
        })) || [];

        diagnostics.push({
          category: "Invitations R√©centes",
          status: invError ? "error" : "success",
          message: invError
            ? "‚ùå Erreur lors de la r√©cup√©ration des invitations"
            : `‚úÖ ${recentInvitations?.length || 0} invitations trouv√©es`,
          details: {
            count: recentInvitations?.length || 0,
            invitations: safeInvitations,
          },
        });
        console.log(`‚úÖ [${requestId}] Check ${checkCount} completed`);
      } catch (error) {
        console.error(`‚ùå [${requestId}] Invitations check failed:`, error.message);
        diagnostics.push({
          category: "Invitations R√©centes",
          status: "error",
          message: "‚ùå Exception lors de la r√©cup√©ration des invitations",
          details: { error: error.message, name: error.name },
        });
      }

      // 7. V√©rifier les notifications envoy√©es
      console.log(`üìã [${requestId}] Check ${++checkCount}: Notifications`);
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);

        const { data: notifications, error: notifError } = await supabase
          .from("waitlist_notifications")
          .select("*")
          .order("sent_at", { ascending: false })
          .limit(5)
          .abortSignal(controller.signal);

        clearTimeout(timeoutId);

        const safeNotifications = notifications?.slice(0, 3).map((n) => ({
          id: n.id,
          status: n.status,
          sent_at: n.sent_at,
        })) || [];

        diagnostics.push({
          category: "Notifications Envoy√©es",
          status: notifError ? "error" : "success",
          message: notifError
            ? "‚ùå Erreur lors de la r√©cup√©ration des notifications"
            : `‚úÖ ${notifications?.length || 0} notifications trouv√©es`,
          details: {
            count: notifications?.length || 0,
            recent: safeNotifications,
          },
        });
        console.log(`‚úÖ [${requestId}] Check ${checkCount} completed`);
      } catch (error) {
        console.error(`‚ùå [${requestId}] Notifications check failed:`, error.message);
        diagnostics.push({
          category: "Notifications Envoy√©es",
          status: "error",
          message: "‚ùå Exception lors de la r√©cup√©ration des notifications",
          details: { error: error.message, name: error.name },
        });
      }
    }

    // 8. R√©sum√© et recommandations
    console.log(`üìã [${requestId}] Preparing summary...`);
    const errors = diagnostics.filter((d) => d.status === "error").length;
    const warnings = diagnostics.filter((d) => d.status === "warning").length;
    const successes = diagnostics.filter((d) => d.status === "success").length;

    const recommendations: string[] = [];

    if (!resendApiKey) {
      recommendations.push(
        "üîß CRITIQUE: Ajoutez RESEND_API_KEY dans Supabase Dashboard > Project Settings > Edge Functions > Secrets"
      );
    }

    if (resendApiKey && !resendApiKey.startsWith("re_")) {
      recommendations.push(
        "‚ö†Ô∏è WARNING: Votre RESEND_API_KEY ne commence pas par 're_'. V√©rifiez que c'est la bonne cl√©."
      );
    }

    if (!resendDomain || resendDomain === "example.com") {
      recommendations.push(
        "üîß IMPORTANT: Configurez RESEND_DOMAIN avec votre domaine v√©rifi√© (ex: janiechiro.com)",
        "‚ö†Ô∏è Sans domaine v√©rifi√©, les emails iront √† delivered@resend.dev (inbox de test Resend)"
      );
    }

    if (!appDomain) {
      recommendations.push(
        "üîß Configurez APP_DOMAIN pour les URLs d'invitation dans les emails"
      );
    }

    const domainNotVerified = diagnostics.find(
      d => d.category === "Configuration Domaine" && d.status === "error"
    );
    if (domainNotVerified) {
      recommendations.push(
        "üö® CRITIQUE: Votre domaine n'est pas v√©rifi√© dans Resend!",
        "üìß Tous les emails vont actuellement √† delivered@resend.dev au lieu de vos patients",
        "‚úÖ Action requise: Allez sur resend.com/domains et v√©rifiez votre domaine",
        "üìñ Consultez RESEND_SETUP_GUIDE.md pour les instructions d√©taill√©es"
      );
    }

    const summary = {
      request_id: requestId,
      timestamp: new Date().toISOString(),
      overall_status:
        errors === 0 ? (warnings === 0 ? "healthy" : "degraded") : "critical",
      diagnostics_run: diagnostics.length,
      results: {
        successes,
        warnings,
        errors,
      },
      diagnostics,
      recommendations,
      next_steps:
        errors === 0
          ? [
              "‚úÖ Syst√®me op√©rationnel",
              "üìß Testez l'envoi d'email via /test-email",
              "üìä Simulez une annulation pour tester le flux complet",
            ]
          : [
              "üîß Corrigez les erreurs critiques ci-dessus",
              "üìñ Consultez DEPLOYMENT_CHECKLIST.md",
              "üí¨ Contactez le support si n√©cessaire",
            ],
    };

    console.log(`‚úÖ [${requestId}] Diagnostic completed: ${successes} success, ${warnings} warnings, ${errors} errors`);
    return createSafeResponse(summary, errors === 0 ? 200 : 500);
  } catch (error) {
    console.error(`‚ùå [${requestId}] Fatal diagnostic error:`, error);
    const errorResponse = {
      request_id: requestId,
      error: "Erreur lors du diagnostic",
      message: error.message || "Unknown error",
      name: error.name || "Error",
      timestamp: new Date().toISOString(),
    };
    return createSafeResponse(errorResponse, 500);
  }
});